{
    "docs": [
        {
            "location": "/", 
            "text": "Carry\n\n\nClojureScript single-page application framework inspired by\n\nre-frame\n,\n\nElm architecture\n,\n\nRedux\n and\n\nCerebral\n.\n\n\nThe core of the framework is a simple state management library. \nUI binding, history management, debugging, etc. are implemented as separate optional packages.\n\n\n\n\nFeatures\n\n\n\n\nExplicit functional API with no globals making apps easy to extend and unit test.\n\n\nMiddleware-friendly design for adding cross-cutting concerns such as persistence, logging, etc.\n\n\nAgnostic to UI layer.\n\n\nReagent\n bindings package achieves code readability and rendering optimization\nusing view-model/view separation based on Reagent reactions (\nsimilarly to re-frame\n).\n\n\nTime traveling debugger inspired by \nRedux DevTools\n and \nCerebral Debugger\n.\n\n\nLive code editing using \nFigwheel\n and debugger's replay mode.\n\n\nElm-ish architecture\n can be applied to reuse apps inside other apps (aka \"fractality\").\n\n\nHistory middleware implements transparent sync between model and current URL and\ndoes not dictate use of any particular routing library. \n\n\n\n\nDesign\n\n\n\n\n\n\nAn app is defined by its initial model value, controller and reconciler.\n\n\nAll app state is stored inside a single model atom.\n\n\nAnyone can read model value at any given time and subscribe to its changes.\n\n\nController function receives signals to perform side effects and dispatch actions.\n\n\nAnyone can dispatch a new signal: controller, views, timers, etc.\n\n\nOnly controller can dispatch actions.\n\n\nModel can be modified only by dispatching actions.\n\n\nReconciler is a pure function which returns a new model value based on an incoming action.\n\n\nWhen UI layer subscribes to model changes we get a notorious unidirectional data flow: UI -\n signal -\n action -\n model -\n UI -\n etc.\n\n\n\n\nExample\n\n\nDemo\n,\n\nSource code\n\n\nCounter spec and UI:\n\n\n(ns counter.core\n  (:require [cljs.core.match :refer-macros [match]])\n  (:require-macros [reagent.ratom :refer [reaction]]))\n\n(def -initial-model {:val 0})\n\n(defn -control\n  [model signal _dispatch-signal dispatch-action]\n  (match signal\n         :on-start nil\n         :on-stop nil\n\n         :on-increment\n         (dispatch-action :increment)\n\n         :on-decrement\n         (dispatch-action :decrement)\n\n         :on-increment-if-odd\n         (when (odd? (:val @model))\n           (dispatch-action :increment))\n\n         :on-increment-async\n         (.setTimeout js/window #(dispatch-action :increment) 1000)))\n\n(defn -reconcile\n  [model action]\n  (match action\n         :increment (update model :val inc)\n         :decrement (update model :val dec)))\n\n(defn view-model\n  [model]\n  {:counter (reaction (str \n#\n (:val @model)))})\n\n(defn view\n  [{:keys [counter] :as _view-model} dispatch]\n  [:p\n   @counter \n \n\n   [:button {:on-click #(dispatch :on-increment)} \n+\n] \n \n\n   [:button {:on-click #(dispatch :on-decrement)} \n-\n] \n \n\n   [:button {:on-click #(dispatch :on-increment-if-odd)} \nIncrement if odd\n] \n \n\n   [:button {:on-click #(dispatch :on-increment-async)} \nIncrement async\n]])\n\n(def spec {:initial-model -initial-model\n           :control       -control\n           :reconcile     -reconcile})\n\n\n\n\nMain file:\n\n\n(ns app.core\n  (:require [counter.core :as counter]\n            [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n(let [app (carry/app counter/spec)\n      [_ app-view] (carry-reagent/connect app counter/view-model counter/view)]\n    (r/render app-view (.getElementById js/document \nroot\n))\n    ((:dispatch-signal app) :on-start))\n\n\n\n\nPackages\n\n\nUI Bindings\n\n\n\n\nReagent\n\n\n\n\nMiddleware\n\n\n\n\nDebugger\n\n\nHistory\n\n\nLogging\n\n\nPersistence\n\n\nSchema\n\n\n\n\nDocumentation\n\n\nMore information can be found at \nthe project site\n:\n\n\n\n\nUser Guide\n\n\nExamples\n\n\nAPI Reference\n\n\nDeveloper Guide\n\n\n\n\nLicense\n\n\nCopyright \u00a9 2016 Yuri Govorushchenko.\n\n\nReleased under an MIT license.", 
            "title": "Readme"
        }, 
        {
            "location": "/#carry", 
            "text": "ClojureScript single-page application framework inspired by re-frame , Elm architecture , Redux  and Cerebral .  The core of the framework is a simple state management library. \nUI binding, history management, debugging, etc. are implemented as separate optional packages.", 
            "title": "Carry"
        }, 
        {
            "location": "/#features", 
            "text": "Explicit functional API with no globals making apps easy to extend and unit test.  Middleware-friendly design for adding cross-cutting concerns such as persistence, logging, etc.  Agnostic to UI layer.  Reagent  bindings package achieves code readability and rendering optimization\nusing view-model/view separation based on Reagent reactions ( similarly to re-frame ).  Time traveling debugger inspired by  Redux DevTools  and  Cerebral Debugger .  Live code editing using  Figwheel  and debugger's replay mode.  Elm-ish architecture  can be applied to reuse apps inside other apps (aka \"fractality\").  History middleware implements transparent sync between model and current URL and\ndoes not dictate use of any particular routing library.", 
            "title": "Features"
        }, 
        {
            "location": "/#design", 
            "text": "An app is defined by its initial model value, controller and reconciler.  All app state is stored inside a single model atom.  Anyone can read model value at any given time and subscribe to its changes.  Controller function receives signals to perform side effects and dispatch actions.  Anyone can dispatch a new signal: controller, views, timers, etc.  Only controller can dispatch actions.  Model can be modified only by dispatching actions.  Reconciler is a pure function which returns a new model value based on an incoming action.  When UI layer subscribes to model changes we get a notorious unidirectional data flow: UI -  signal -  action -  model -  UI -  etc.", 
            "title": "Design"
        }, 
        {
            "location": "/#example", 
            "text": "Demo , Source code  Counter spec and UI:  (ns counter.core\n  (:require [cljs.core.match :refer-macros [match]])\n  (:require-macros [reagent.ratom :refer [reaction]]))\n\n(def -initial-model {:val 0})\n\n(defn -control\n  [model signal _dispatch-signal dispatch-action]\n  (match signal\n         :on-start nil\n         :on-stop nil\n\n         :on-increment\n         (dispatch-action :increment)\n\n         :on-decrement\n         (dispatch-action :decrement)\n\n         :on-increment-if-odd\n         (when (odd? (:val @model))\n           (dispatch-action :increment))\n\n         :on-increment-async\n         (.setTimeout js/window #(dispatch-action :increment) 1000)))\n\n(defn -reconcile\n  [model action]\n  (match action\n         :increment (update model :val inc)\n         :decrement (update model :val dec)))\n\n(defn view-model\n  [model]\n  {:counter (reaction (str  #  (:val @model)))})\n\n(defn view\n  [{:keys [counter] :as _view-model} dispatch]\n  [:p\n   @counter    \n   [:button {:on-click #(dispatch :on-increment)}  + ]    \n   [:button {:on-click #(dispatch :on-decrement)}  - ]    \n   [:button {:on-click #(dispatch :on-increment-if-odd)}  Increment if odd ]    \n   [:button {:on-click #(dispatch :on-increment-async)}  Increment async ]])\n\n(def spec {:initial-model -initial-model\n           :control       -control\n           :reconcile     -reconcile})  Main file:  (ns app.core\n  (:require [counter.core :as counter]\n            [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n(let [app (carry/app counter/spec)\n      [_ app-view] (carry-reagent/connect app counter/view-model counter/view)]\n    (r/render app-view (.getElementById js/document  root ))\n    ((:dispatch-signal app) :on-start))", 
            "title": "Example"
        }, 
        {
            "location": "/#packages", 
            "text": "", 
            "title": "Packages"
        }, 
        {
            "location": "/#ui-bindings", 
            "text": "Reagent", 
            "title": "UI Bindings"
        }, 
        {
            "location": "/#middleware", 
            "text": "Debugger  History  Logging  Persistence  Schema", 
            "title": "Middleware"
        }, 
        {
            "location": "/#documentation", 
            "text": "More information can be found at  the project site :   User Guide  Examples  API Reference  Developer Guide", 
            "title": "Documentation"
        }, 
        {
            "location": "/#license", 
            "text": "Copyright \u00a9 2016 Yuri Govorushchenko.  Released under an MIT license.", 
            "title": "License"
        }, 
        {
            "location": "/user-guide/", 
            "text": "Basics\n\n\nThis section explains everything you need to start making apps with Carry. \n\n\nApp\n\n\n\n\nIn a Carry application all the code you write is encapsulated behind a single \napp\n instance. \nAn app is a map with keys:\n\n\n\n\n:model\n - a read-only atom, an in-memory representation of an app state\n\n\n:dispatch-signal\n - a function for interaction with an app, always returns nil\n\n\n\n\nOne can consider an app to be a black box which exposes its current state and modifies it on getting signals from an external world.\nIt can also affect an external world as a response to a signal, i.e. perform \"side effects\".\n\n\nModel\n\n\nModel represents an entire state of an app. \n\n\nOne can access app's model via \n:model\n key to obtain a read-only atom that can be dereferenced and watched, but cannot be mutated:\n\n\n(def my-model (:model app))\n\n@my-model\n;=\n {...}\n\n(add-watch my-model :my-watcher\n           (fn [_key _atom old-state new-state]\n             (when (not= old-state new-state)\n               (println \nmodel value has changed!\n))))\n\n(reset! my-model {:foo :bar})\n;=\n Error: read-only atom cannot be reset to {:foo :bar}\n\n((:dispatch-signal app) some-model-changing-signal)\n;=\n model value has changed!\n\n(remove-watch my-model :my-watcher)\n\n\n\n\nCarry requires a model value to be a map. This convention allows writing reusable packages that can store additional data into any Carry app.\nAs an example, \ncarry-history\n adds \n:token\n to a model.\n\n\nSignals\n\n\nSignal\n is an object which represents a user's intention or, looking at it from a different angle, a system event. \nSignal can be synchronously sent to an app by calling its \ndispatch-signal\n function:\n\n\n((:dispatch-signal my-app) my-signal)\n\n\n\n\nCarry accepts signals of any type. But usually signal is a just keyword with the \"on-\" prefix or\na serializable vector with a keyword and an additional payload:\n\n\n:on-clear-completed\n[:on-update-todo id val]\n[:carry-history.core/on-enter token]\n\n\n\n\nCreating an App\n\n\nIn order to create an instance of a Carry app a user has to pass a \nspec\n into the \napp\n function:\n\n\n(def my-app (carry/app my-spec))\n\n\n\n\nA spec is a map with keys:\n\n\n\n\n:initial-model\n - an initial model value\n\n\n:control\n - a function for handling signals\n\n\n:reconcile\n - a function for handling actions\n\n\n\n\nIn other words, a spec is needed to define a runtime behavior of an app:\n\n\n\n\nControl\n\n\nController (control function, control)\n is a part of an application responsible for handling incoming signals. \nIt can dispatch new signals, modify app model (by dispatching actions) and perform any side effects (e.g. send data to a server).\nController is free to contain asynchronous code. The signature of a control function:\n\n\n(defn control\n  [model signal dispatch-signal dispatch-action])\n\n\n\n\n\n\nmodel\n - a read-only atom, the same as app's \n:model\n\n\nsignal\n - an incoming signal \n\n\ndispatch-signal\n - a synchronous function for dispatching new signals, always returns \nnil\n, the same as app's \n:dispatch-signal\n\n\ndispatch-action\n - a synchronous function for modifying a model, always returns \nnil\n\n\nReturn value will not be used\n\n\n\n\nBy convention, control should be able to at least handle \n:on-start\n and \n:on-stop\n signals.\nAs we'll see later, it's required by middleware with setup/teardown logic and to support hot reloading.\n\n\nIt is convenient (but not required) to use \npattern matching\n \nto switch between signals and destructure signals with payload.\nAs an example, this is a controller from \nfriend-list\n demo app:\n\n\n(ns friend-list.core\n  (:require [carry-history.core :as h]\n            ; ...\n            [goog.functions :refer [debounce]]\n            [cljs.core.match :refer-macros [match]]))\n\n; It's recommended to create a factory function if controller uses external dependencies.\n; It makes code more decoupled and \n; easier to unit test (stubs/mocks can be easily used instead of real implementations).\n; In this example browser history manager and API client are external dependencies.\n(defn -new-control\n  [history api-search]\n  ; Some helper functions.\n  ; On successful search a new :on-search-success signal will be dispatched.\n  (let [search (fn [q dispatch-signal] (api-search q #(dispatch-signal [:on-search-success q %])))\n        search-on-input (debounce (fn [q dispatch-signal]\n                                    (h/push-token history q)\n                                    (search q dispatch-signal))\n                                  300)]\n    ; Function name is specified for better stacktraces.\n    (fn control\n      [model signal dispatch-signal dispatch-action]\n      (match signal\n             ; This application has no custom setup/teardown logic\n             ; so just return nil on standard signals:             \n             :on-start nil\n             :on-stop nil\n\n             ; Macro will throw an exception on unknown signals.\n\n             ; Signal destructuring example \n             [:on-input q]\n             (do\n               ; Update model.\n               (dispatch-action [:set-query q])\n\n               ; Begin (possibly async) searching.\n               (search-on-input q dispatch-signal))\n\n             ; ...\n\n             [:on-search-success q friends]\n             ; Note that model has to be dereferenced to get its value.\n             (if (= (:query @model) q)\n               (dispatch-action [:set-friends friends])\n               (println \nignore response for\n (pr-str q)\n                        \nbecause current query is\n (pr-str (:query @model))))))))\n\n; ...\n\n; Dependencies will be injected in a spec factory function:\n(defn new-spec\n  [history api-search]\n  {; ...\n   :control (-new-control history api-search)})\n\n; ...\n\n; Create and start an app using concrete dependencies.\n(def my-app (carry/app (new-spec my-history my-api-client)))\n((:dispatch-signal app) :on-start)\n\n\n\n\nActions\n\n\nAction\n is an object which represents an intention to modify a model.\nActions can be dispatched only from within a control function via \ndispatch-action\n.\n\n\nSimilar to signals, actions are usually keywords or vectors, for instance:\n\n\n:increment\n[:set-query q]\n\n\n\n\nReconcile\n\n\nReconciler (reconcile function, reconcile)\n is a part of an application responsible for handling incoming actions.\nIt's a pure function which returns a new model value based on a current model value and an incoming action.\nOn getting an action an app passes it into a reconciler and then resets app model value with the result.\n\n\nA simple example from \nfriend-list\n demo app:\n\n\n(defn -reconcile\n  [model action]\n  (match action\n         [:set-query q]\n         (assoc model :query q)\n\n         [:set-friends friends]\n         (assoc model :friends friends)))\n\n\n\n\nIt's important to not put any async code, side effects or nondeterministic code (e.g. random number generation)\ninto reconciler. Otherwise, it will make replaying actions unpredictable and break time traveling debugging.\n\n\nUsage with Reagent\n\n\nThis section is a WIP. Please see examples in a meantime.\n\n\nAdvanced\n\n\nMiddleware\n\n\nThis section is a WIP. Please see examples in a meantime.\n\n\nUsage with Figwheel\n\n\nThis section is a WIP. Please see examples in a meantime.\n\n\nWriting Tests\n\n\nThis section is a WIP. Please see examples in a meantime.\n\n\nElm-ish Architecture\n\n\nThis section is a WIP. Please see examples in a meantime.\n\n\nUsage with Datascript\n\n\nThis section is a WIP. Please see examples in a meantime.\n\n\nDebugging\n\n\nThis section is a WIP. Please see examples in a meantime.", 
            "title": "User Guide"
        }, 
        {
            "location": "/user-guide/#basics", 
            "text": "This section explains everything you need to start making apps with Carry.", 
            "title": "Basics"
        }, 
        {
            "location": "/user-guide/#app", 
            "text": "In a Carry application all the code you write is encapsulated behind a single  app  instance. \nAn app is a map with keys:   :model  - a read-only atom, an in-memory representation of an app state  :dispatch-signal  - a function for interaction with an app, always returns nil   One can consider an app to be a black box which exposes its current state and modifies it on getting signals from an external world.\nIt can also affect an external world as a response to a signal, i.e. perform \"side effects\".", 
            "title": "App"
        }, 
        {
            "location": "/user-guide/#model", 
            "text": "Model represents an entire state of an app.   One can access app's model via  :model  key to obtain a read-only atom that can be dereferenced and watched, but cannot be mutated:  (def my-model (:model app))\n\n@my-model\n;=  {...}\n\n(add-watch my-model :my-watcher\n           (fn [_key _atom old-state new-state]\n             (when (not= old-state new-state)\n               (println  model value has changed! ))))\n\n(reset! my-model {:foo :bar})\n;=  Error: read-only atom cannot be reset to {:foo :bar}\n\n((:dispatch-signal app) some-model-changing-signal)\n;=  model value has changed!\n\n(remove-watch my-model :my-watcher)  Carry requires a model value to be a map. This convention allows writing reusable packages that can store additional data into any Carry app.\nAs an example,  carry-history  adds  :token  to a model.", 
            "title": "Model"
        }, 
        {
            "location": "/user-guide/#signals", 
            "text": "Signal  is an object which represents a user's intention or, looking at it from a different angle, a system event. \nSignal can be synchronously sent to an app by calling its  dispatch-signal  function:  ((:dispatch-signal my-app) my-signal)  Carry accepts signals of any type. But usually signal is a just keyword with the \"on-\" prefix or\na serializable vector with a keyword and an additional payload:  :on-clear-completed\n[:on-update-todo id val]\n[:carry-history.core/on-enter token]", 
            "title": "Signals"
        }, 
        {
            "location": "/user-guide/#creating-an-app", 
            "text": "In order to create an instance of a Carry app a user has to pass a  spec  into the  app  function:  (def my-app (carry/app my-spec))  A spec is a map with keys:   :initial-model  - an initial model value  :control  - a function for handling signals  :reconcile  - a function for handling actions   In other words, a spec is needed to define a runtime behavior of an app:", 
            "title": "Creating an App"
        }, 
        {
            "location": "/user-guide/#control", 
            "text": "Controller (control function, control)  is a part of an application responsible for handling incoming signals. \nIt can dispatch new signals, modify app model (by dispatching actions) and perform any side effects (e.g. send data to a server).\nController is free to contain asynchronous code. The signature of a control function:  (defn control\n  [model signal dispatch-signal dispatch-action])   model  - a read-only atom, the same as app's  :model  signal  - an incoming signal   dispatch-signal  - a synchronous function for dispatching new signals, always returns  nil , the same as app's  :dispatch-signal  dispatch-action  - a synchronous function for modifying a model, always returns  nil  Return value will not be used   By convention, control should be able to at least handle  :on-start  and  :on-stop  signals.\nAs we'll see later, it's required by middleware with setup/teardown logic and to support hot reloading.  It is convenient (but not required) to use  pattern matching  \nto switch between signals and destructure signals with payload.\nAs an example, this is a controller from  friend-list  demo app:  (ns friend-list.core\n  (:require [carry-history.core :as h]\n            ; ...\n            [goog.functions :refer [debounce]]\n            [cljs.core.match :refer-macros [match]]))\n\n; It's recommended to create a factory function if controller uses external dependencies.\n; It makes code more decoupled and \n; easier to unit test (stubs/mocks can be easily used instead of real implementations).\n; In this example browser history manager and API client are external dependencies.\n(defn -new-control\n  [history api-search]\n  ; Some helper functions.\n  ; On successful search a new :on-search-success signal will be dispatched.\n  (let [search (fn [q dispatch-signal] (api-search q #(dispatch-signal [:on-search-success q %])))\n        search-on-input (debounce (fn [q dispatch-signal]\n                                    (h/push-token history q)\n                                    (search q dispatch-signal))\n                                  300)]\n    ; Function name is specified for better stacktraces.\n    (fn control\n      [model signal dispatch-signal dispatch-action]\n      (match signal\n             ; This application has no custom setup/teardown logic\n             ; so just return nil on standard signals:             \n             :on-start nil\n             :on-stop nil\n\n             ; Macro will throw an exception on unknown signals.\n\n             ; Signal destructuring example \n             [:on-input q]\n             (do\n               ; Update model.\n               (dispatch-action [:set-query q])\n\n               ; Begin (possibly async) searching.\n               (search-on-input q dispatch-signal))\n\n             ; ...\n\n             [:on-search-success q friends]\n             ; Note that model has to be dereferenced to get its value.\n             (if (= (:query @model) q)\n               (dispatch-action [:set-friends friends])\n               (println  ignore response for  (pr-str q)\n                         because current query is  (pr-str (:query @model))))))))\n\n; ...\n\n; Dependencies will be injected in a spec factory function:\n(defn new-spec\n  [history api-search]\n  {; ...\n   :control (-new-control history api-search)})\n\n; ...\n\n; Create and start an app using concrete dependencies.\n(def my-app (carry/app (new-spec my-history my-api-client)))\n((:dispatch-signal app) :on-start)", 
            "title": "Control"
        }, 
        {
            "location": "/user-guide/#actions", 
            "text": "Action  is an object which represents an intention to modify a model.\nActions can be dispatched only from within a control function via  dispatch-action .  Similar to signals, actions are usually keywords or vectors, for instance:  :increment\n[:set-query q]", 
            "title": "Actions"
        }, 
        {
            "location": "/user-guide/#reconcile", 
            "text": "Reconciler (reconcile function, reconcile)  is a part of an application responsible for handling incoming actions.\nIt's a pure function which returns a new model value based on a current model value and an incoming action.\nOn getting an action an app passes it into a reconciler and then resets app model value with the result.  A simple example from  friend-list  demo app:  (defn -reconcile\n  [model action]\n  (match action\n         [:set-query q]\n         (assoc model :query q)\n\n         [:set-friends friends]\n         (assoc model :friends friends)))  It's important to not put any async code, side effects or nondeterministic code (e.g. random number generation)\ninto reconciler. Otherwise, it will make replaying actions unpredictable and break time traveling debugging.", 
            "title": "Reconcile"
        }, 
        {
            "location": "/user-guide/#usage-with-reagent", 
            "text": "This section is a WIP. Please see examples in a meantime.", 
            "title": "Usage with Reagent"
        }, 
        {
            "location": "/user-guide/#advanced", 
            "text": "", 
            "title": "Advanced"
        }, 
        {
            "location": "/user-guide/#middleware", 
            "text": "This section is a WIP. Please see examples in a meantime.", 
            "title": "Middleware"
        }, 
        {
            "location": "/user-guide/#usage-with-figwheel", 
            "text": "This section is a WIP. Please see examples in a meantime.", 
            "title": "Usage with Figwheel"
        }, 
        {
            "location": "/user-guide/#writing-tests", 
            "text": "This section is a WIP. Please see examples in a meantime.", 
            "title": "Writing Tests"
        }, 
        {
            "location": "/user-guide/#elm-ish-architecture", 
            "text": "This section is a WIP. Please see examples in a meantime.", 
            "title": "Elm-ish Architecture"
        }, 
        {
            "location": "/user-guide/#usage-with-datascript", 
            "text": "This section is a WIP. Please see examples in a meantime.", 
            "title": "Usage with Datascript"
        }, 
        {
            "location": "/user-guide/#debugging", 
            "text": "This section is a WIP. Please see examples in a meantime.", 
            "title": "Debugging"
        }, 
        {
            "location": "/examples/", 
            "text": "All source code can be found in \nthe Github repository\n.\n\n\nAll apps support hot reloading and REPL debugging via \nFigwheel\n.\n\n\nCounter Vanilla\n\n\nSource code\n\n\nDemo\n\n\nThe most trivial example.\n\n\nCounter\n\n\nSource code\n\n\nDemo\n\n\nThe basic example of using Carry with Reagent.\n\n\nFriend List\n\n\nSource code\n\n\nDemo\n\n\nInspired by this \nproblem\n about dynamic search input.\nDemonstrates how to dispatch new signals from app controller and also features:\n\n\n\n\nbasic routing\n\n\nmodel validation using \nSchema\n\n\ntime traveling debugger\n\n\nlogging to console\n\n\nunit tests\n\n\n\n\nTodoMVC\n\n\nSource code\n\n\nDemo\n\n\nSee \ntodomvc.com\n.\n\n\nFeatures:\n\n\n\n\nrouting using \nSilk\n\n\nlocal storage persistence\n\n\ntime traveling debugger\n\n\nlogging to console\n\n\nmodel validation using \nSchema\n\n\nuses \nSpecter\n for model updates\n\n\n\n\nCounter with DataScript\n\n\nSource code\n\n\nDemo\n\n\nSimplest example of using \nDataScript\n in-memory database for a model.\n\n\nShopping Cart\n\n\nSource code\n\n\nDemo\n\n\nMore advanced example of using \nDataScript\n.\nInspired by \nflux-comparison\n problem.\n\n\nElm-ish Architecture Examples\n\n\nThe proof-of-concept examples of applying \nElm-ish architecture\n\nfor reusing existing Carry apps when building a bigger app.\nIt's a debatable design pattern because of the resulting code complexity, so use it with caution.\n\n\nSubapps\n\n\nSource code\n\n\nDemo\n\n\nIn this project \ncounter app\n and \nfriend list app\n instances are \"statically\" added to the app spec.\nSeveral helper methods are extracted to make it easy to include any subapp at the time of app instantiation.\n\n\nCounter List\n\n\nSource code\n\n\nDemo\n\n\nIn this example \ncounter app\n instances are created and removed dynamically after app is started.", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#counter-vanilla", 
            "text": "Source code  Demo  The most trivial example.", 
            "title": "Counter Vanilla"
        }, 
        {
            "location": "/examples/#counter", 
            "text": "Source code  Demo  The basic example of using Carry with Reagent.", 
            "title": "Counter"
        }, 
        {
            "location": "/examples/#friend-list", 
            "text": "Source code  Demo  Inspired by this  problem  about dynamic search input.\nDemonstrates how to dispatch new signals from app controller and also features:   basic routing  model validation using  Schema  time traveling debugger  logging to console  unit tests", 
            "title": "Friend List"
        }, 
        {
            "location": "/examples/#todomvc", 
            "text": "Source code  Demo  See  todomvc.com .  Features:   routing using  Silk  local storage persistence  time traveling debugger  logging to console  model validation using  Schema  uses  Specter  for model updates", 
            "title": "TodoMVC"
        }, 
        {
            "location": "/examples/#counter-with-datascript", 
            "text": "Source code  Demo  Simplest example of using  DataScript  in-memory database for a model.", 
            "title": "Counter with DataScript"
        }, 
        {
            "location": "/examples/#shopping-cart", 
            "text": "Source code  Demo  More advanced example of using  DataScript .\nInspired by  flux-comparison  problem.", 
            "title": "Shopping Cart"
        }, 
        {
            "location": "/examples/#elm-ish-architecture-examples", 
            "text": "The proof-of-concept examples of applying  Elm-ish architecture \nfor reusing existing Carry apps when building a bigger app.\nIt's a debatable design pattern because of the resulting code complexity, so use it with caution.", 
            "title": "Elm-ish Architecture Examples"
        }, 
        {
            "location": "/examples/#subapps", 
            "text": "Source code  Demo  In this project  counter app  and  friend list app  instances are \"statically\" added to the app spec.\nSeveral helper methods are extracted to make it easy to include any subapp at the time of app instantiation.", 
            "title": "Subapps"
        }, 
        {
            "location": "/examples/#counter-list", 
            "text": "Source code  Demo  In this example  counter app  instances are created and removed dynamically after app is started.", 
            "title": "Counter List"
        }, 
        {
            "location": "/api/", 
            "text": "It is a placeholder file, it will be replaced by API Reference docs generated by external tool.", 
            "title": "API Reference"
        }, 
        {
            "location": "/dev-guide/", 
            "text": "Documentation\n\n\nProject uses \nMkDocs\n with \nCinder\n theme and \nPlantUML\n to generate documentation static site.\n\nCodox\n is used to generate API reference.\nTasks are scripted using \nPyInvoke\n.\n\n\nServe site pages locally with automatic build (but it won't work for index page): \nmkdocs serve\n\n\nBuild only site pages: \ninv mkdocs\n\n\nBuild API reference into site folder: \ninv api\n\n\nBuild graphs into site folder: \ninv graphs\n\n\nBuild examples into site folder: \ninv examples\n\n\nBuild the whole site: \ninv site\n\n\nDeploying\n\n\nDeploy to Clojars: \nlein deploy clojars\n\n\nDeploy site to gh-pages branch: \nghp-import -p site", 
            "title": "Developer Guide"
        }, 
        {
            "location": "/dev-guide/#documentation", 
            "text": "Project uses  MkDocs  with  Cinder  theme and  PlantUML  to generate documentation static site. Codox  is used to generate API reference.\nTasks are scripted using  PyInvoke .  Serve site pages locally with automatic build (but it won't work for index page):  mkdocs serve  Build only site pages:  inv mkdocs  Build API reference into site folder:  inv api  Build graphs into site folder:  inv graphs  Build examples into site folder:  inv examples  Build the whole site:  inv site", 
            "title": "Documentation"
        }, 
        {
            "location": "/dev-guide/#deploying", 
            "text": "Deploy to Clojars:  lein deploy clojars  Deploy site to gh-pages branch:  ghp-import -p site", 
            "title": "Deploying"
        }
    ]
}