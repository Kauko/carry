{
    "docs": [
        {
            "location": "/", 
            "text": "Carry\n\n\nClojureScript single-page application framework inspired by\n\nre-frame\n,\n\nElm architecture\n,\n\nRedux\n and\n\nCerebral\n.\n\n\nThe core of the framework is a simple state management library with \nUI binding, history management, debugging, etc. implemented as separate optional packages.\n\n\n\n\nFeatures\n\n\n\n\nExplicit functional API with no globals making apps easy to extend and unit test.\n\n\nMiddleware-friendly design for adding cross-cutting concerns such as persistence, logging, etc.\n\n\nAgnostic to UI layer.\n\n\nReagent\n bindings package achieves code readability and rendering optimization\nby view-model/view separation based on Reagent reactions (\nsimilar to re-frame\n).\n\n\nTime traveling debugger inspired by \nRedux DevTools\n and \nCerebral Debugger\n.\n\n\nLive code editing using \nFigwheel\n and debugger's replay mode.\n\n\nElm-ish architecture\n can be applied to reuse apps inside other apps (aka \"fractality\").\n\n\nHistory middleware implements transparent sync between model and current URL and\ndoes not dictate use of any particular routing library. \n\n\n\n\nDesign\n\n\n\n\n\n\nAll app state is stored inside a single model atom. \n\n\nApp is defined by controller, reconciler and initial model value.\n\n\nController function handles signals to perform side-effects and dispatch actions.\n\n\nAnyone can dispatch a new signal into an app: controller itself, views, timers, etc.\n\n\nReconciler is a pure function which returns a modified state based on incoming action.\n\n\nState can be modified only by dispatching actions.\n\n\nAnyone can read model value at any given time and subscribe to its changes.\n\n\nWhen UI layer subscribes to model changes we get a notorious unidirectional data flow: UI -\n signal -\n action -\n model -\n UI -\n etc.\n\n\n\n\nExample\n\n\nDemo\n,\n\nSource code\n\n\nCounter spec and UI:\n\n\n(ns counter.core\n  (:require [reagent.core]\n            [cljs.core.match :refer-macros [match]])\n  (:require-macros [reagent.ratom :refer [reaction]]))\n\n(def -initial-model {:val 0})\n\n(defn -control\n  [model signal _dispatch-signal dispatch-action]\n  (match signal\n         :on-start nil\n         :on-stop nil\n\n         :on-increment\n         (dispatch-action :increment)\n\n         :on-decrement\n         (dispatch-action :decrement)\n\n         :on-increment-if-odd\n         (when (odd? (:val @model))\n           (dispatch-action :increment))\n\n         :on-increment-async\n         (.setTimeout js/window #(dispatch-action :increment) 1000)))\n\n(defn -reconcile\n  [model action]\n  (match action\n         :increment (update model :val inc)\n         :decrement (update model :val dec)))\n\n(defn view-model\n  [model]\n  {:counter (reaction (str \n#\n (:val @model)))})\n\n(defn view\n  [{:keys [counter] :as _view-model} dispatch]\n  [:p\n   @counter \n \n\n   [:button {:on-click #(dispatch :on-increment)} \n+\n] \n \n\n   [:button {:on-click #(dispatch :on-decrement)} \n-\n] \n \n\n   [:button {:on-click #(dispatch :on-increment-if-odd)} \nIncrement if odd\n] \n \n\n   [:button {:on-click #(dispatch :on-increment-async)} \nIncrement async\n]])\n\n(def spec {:initial-model -initial-model\n           :control       -control\n           :reconcile     -reconcile})\n\n\n\n\nMain file:\n\n\n(ns app.core\n  (:require [counter.core :as counter]\n            [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n(let [app (carry/app counter/spec)\n      [_ app-view] (carry-reagent/connect app counter/view-model counter/view)]\n    (r/render app-view (.getElementById js/document \nroot\n))\n    ((:dispatch-signal app) :on-start))\n\n\n\n\nPackages\n\n\nUI Bindings\n\n\n\n\nReagent\n\n\n\n\nMiddleware\n\n\n\n\nDebugger\n\n\nHistory\n\n\nLogging\n\n\nPersistence\n\n\nSchema\n\n\n\n\nDocumentation\n\n\nMore information can be found at \nthe project site\n:\n\n\n\n\nExamples\n\n\nAPI Reference\n\n\nDeveloper Guide\n\n\n\n\nLicense\n\n\nCopyright \u00a9 2016 Yuri Govorushchenko.\n\n\nReleased under an MIT license.", 
            "title": "Readme"
        }, 
        {
            "location": "/#carry", 
            "text": "ClojureScript single-page application framework inspired by re-frame , Elm architecture , Redux  and Cerebral .  The core of the framework is a simple state management library with \nUI binding, history management, debugging, etc. implemented as separate optional packages.", 
            "title": "Carry"
        }, 
        {
            "location": "/#features", 
            "text": "Explicit functional API with no globals making apps easy to extend and unit test.  Middleware-friendly design for adding cross-cutting concerns such as persistence, logging, etc.  Agnostic to UI layer.  Reagent  bindings package achieves code readability and rendering optimization\nby view-model/view separation based on Reagent reactions ( similar to re-frame ).  Time traveling debugger inspired by  Redux DevTools  and  Cerebral Debugger .  Live code editing using  Figwheel  and debugger's replay mode.  Elm-ish architecture  can be applied to reuse apps inside other apps (aka \"fractality\").  History middleware implements transparent sync between model and current URL and\ndoes not dictate use of any particular routing library.", 
            "title": "Features"
        }, 
        {
            "location": "/#design", 
            "text": "All app state is stored inside a single model atom.   App is defined by controller, reconciler and initial model value.  Controller function handles signals to perform side-effects and dispatch actions.  Anyone can dispatch a new signal into an app: controller itself, views, timers, etc.  Reconciler is a pure function which returns a modified state based on incoming action.  State can be modified only by dispatching actions.  Anyone can read model value at any given time and subscribe to its changes.  When UI layer subscribes to model changes we get a notorious unidirectional data flow: UI -  signal -  action -  model -  UI -  etc.", 
            "title": "Design"
        }, 
        {
            "location": "/#example", 
            "text": "Demo , Source code  Counter spec and UI:  (ns counter.core\n  (:require [reagent.core]\n            [cljs.core.match :refer-macros [match]])\n  (:require-macros [reagent.ratom :refer [reaction]]))\n\n(def -initial-model {:val 0})\n\n(defn -control\n  [model signal _dispatch-signal dispatch-action]\n  (match signal\n         :on-start nil\n         :on-stop nil\n\n         :on-increment\n         (dispatch-action :increment)\n\n         :on-decrement\n         (dispatch-action :decrement)\n\n         :on-increment-if-odd\n         (when (odd? (:val @model))\n           (dispatch-action :increment))\n\n         :on-increment-async\n         (.setTimeout js/window #(dispatch-action :increment) 1000)))\n\n(defn -reconcile\n  [model action]\n  (match action\n         :increment (update model :val inc)\n         :decrement (update model :val dec)))\n\n(defn view-model\n  [model]\n  {:counter (reaction (str  #  (:val @model)))})\n\n(defn view\n  [{:keys [counter] :as _view-model} dispatch]\n  [:p\n   @counter    \n   [:button {:on-click #(dispatch :on-increment)}  + ]    \n   [:button {:on-click #(dispatch :on-decrement)}  - ]    \n   [:button {:on-click #(dispatch :on-increment-if-odd)}  Increment if odd ]    \n   [:button {:on-click #(dispatch :on-increment-async)}  Increment async ]])\n\n(def spec {:initial-model -initial-model\n           :control       -control\n           :reconcile     -reconcile})  Main file:  (ns app.core\n  (:require [counter.core :as counter]\n            [carry.core :as carry]\n            [carry-reagent.core :as carry-reagent]\n            [reagent.core :as r]))\n\n(let [app (carry/app counter/spec)\n      [_ app-view] (carry-reagent/connect app counter/view-model counter/view)]\n    (r/render app-view (.getElementById js/document  root ))\n    ((:dispatch-signal app) :on-start))", 
            "title": "Example"
        }, 
        {
            "location": "/#packages", 
            "text": "", 
            "title": "Packages"
        }, 
        {
            "location": "/#ui-bindings", 
            "text": "Reagent", 
            "title": "UI Bindings"
        }, 
        {
            "location": "/#middleware", 
            "text": "Debugger  History  Logging  Persistence  Schema", 
            "title": "Middleware"
        }, 
        {
            "location": "/#documentation", 
            "text": "More information can be found at  the project site :   Examples  API Reference  Developer Guide", 
            "title": "Documentation"
        }, 
        {
            "location": "/#license", 
            "text": "Copyright \u00a9 2016 Yuri Govorushchenko.  Released under an MIT license.", 
            "title": "License"
        }, 
        {
            "location": "/examples/", 
            "text": "All source code can be found in \nthe Github repository\n.\n\n\nAll apps support hot reloading and REPL debugging via \nFigwheel\n.\n\n\nCounter Vanilla\n\n\nSource code\n\n\nDemo\n\n\nThe most trivial example.\n\n\nCounter\n\n\nSource code\n\n\nDemo\n\n\nThe basic example of using Carry with Reagent.\n\n\nFriend List\n\n\nSource code\n\n\nDemo\n\n\nInspired by this \nproblem\n about dynamic search input.\nDemonstrates how to dispatch new signals from app controller and also features:\n\n\n\n\nbasic routing\n\n\nmodel validation using \nSchema\n\n\ntime traveling debugger\n\n\nlogging to console\n\n\nunit tests\n\n\n\n\nTodoMVC\n\n\nSource code\n\n\nDemo\n\n\nSee \ntodomvc.com\n.\n\n\nFeatures:\n\n\n\n\nrouting using \nSilk\n\n\nlocal storage persistence\n\n\ntime traveling debugger\n\n\nlogging to console\n\n\nmodel validation using \nSchema\n\n\nuses \nSpecter\n for model updates\n\n\n\n\nCounter with DataScript\n\n\nSource code\n\n\nDemo\n\n\nSimplest example of using \nDataScript\n in-memory database for a model.\n\n\nShopping Cart\n\n\nSource code\n\n\nDemo\n\n\nMore advanced example of using \nDataScript\n.\nInspired by \nflux-comparison\n problem.\n\n\nElm-ish Architecture Examples\n\n\nThe proof-of-concept examples of applying \nElm-ish architecture\n\nfor reusing existing Carry apps when building a bigger app.\nIt's a debatable design pattern because of the resulting code complexity, so use it with caution.\n\n\nSubapps\n\n\nSource code\n\n\nDemo\n\n\nIn this project \ncounter app\n and \nfriend list app\n instances are \"statically\" added to the app spec.\nSeveral helper methods are extracted to make it easy to include any subapp at the time of app instantiation.\n\n\nCounter List\n\n\nSource code\n\n\nDemo\n\n\nIn this example \ncounter app\n instances are created and removed dynamically after app is started.", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#counter-vanilla", 
            "text": "Source code  Demo  The most trivial example.", 
            "title": "Counter Vanilla"
        }, 
        {
            "location": "/examples/#counter", 
            "text": "Source code  Demo  The basic example of using Carry with Reagent.", 
            "title": "Counter"
        }, 
        {
            "location": "/examples/#friend-list", 
            "text": "Source code  Demo  Inspired by this  problem  about dynamic search input.\nDemonstrates how to dispatch new signals from app controller and also features:   basic routing  model validation using  Schema  time traveling debugger  logging to console  unit tests", 
            "title": "Friend List"
        }, 
        {
            "location": "/examples/#todomvc", 
            "text": "Source code  Demo  See  todomvc.com .  Features:   routing using  Silk  local storage persistence  time traveling debugger  logging to console  model validation using  Schema  uses  Specter  for model updates", 
            "title": "TodoMVC"
        }, 
        {
            "location": "/examples/#counter-with-datascript", 
            "text": "Source code  Demo  Simplest example of using  DataScript  in-memory database for a model.", 
            "title": "Counter with DataScript"
        }, 
        {
            "location": "/examples/#shopping-cart", 
            "text": "Source code  Demo  More advanced example of using  DataScript .\nInspired by  flux-comparison  problem.", 
            "title": "Shopping Cart"
        }, 
        {
            "location": "/examples/#elm-ish-architecture-examples", 
            "text": "The proof-of-concept examples of applying  Elm-ish architecture \nfor reusing existing Carry apps when building a bigger app.\nIt's a debatable design pattern because of the resulting code complexity, so use it with caution.", 
            "title": "Elm-ish Architecture Examples"
        }, 
        {
            "location": "/examples/#subapps", 
            "text": "Source code  Demo  In this project  counter app  and  friend list app  instances are \"statically\" added to the app spec.\nSeveral helper methods are extracted to make it easy to include any subapp at the time of app instantiation.", 
            "title": "Subapps"
        }, 
        {
            "location": "/examples/#counter-list", 
            "text": "Source code  Demo  In this example  counter app  instances are created and removed dynamically after app is started.", 
            "title": "Counter List"
        }, 
        {
            "location": "/api/", 
            "text": "It is a placeholder file, it will be replaced by API Reference docs generated by external tool.", 
            "title": "API Reference"
        }, 
        {
            "location": "/dev-guide/", 
            "text": "Documentation\n\n\nProject uses \nMkDocs\n with \nCinder\n theme and \nPlantUML\n to generate documentation static site.\n\nCodox\n is used to generate API reference.\nTasks are scripted using \nPyInvoke\n.\n\n\nServe site pages locally with automatic build (but it won't work for index page): \nmkdocs serve\n\n\nBuild only site pages: \ninv mkdocs\n\n\nBuild API reference into site folder: \ninv api\n\n\nBuild graphs into site folder: \ninv graphs\n\n\nBuild examples into site folder: \ninv examples\n\n\nBuild the whole site: \ninv site\n\n\nDeploying\n\n\nDeploy to Clojars: \nlein deploy clojars\n\n\nDeploy site to gh-pages branch: \nghp-import -p site", 
            "title": "Developer Guide"
        }, 
        {
            "location": "/dev-guide/#documentation", 
            "text": "Project uses  MkDocs  with  Cinder  theme and  PlantUML  to generate documentation static site. Codox  is used to generate API reference.\nTasks are scripted using  PyInvoke .  Serve site pages locally with automatic build (but it won't work for index page):  mkdocs serve  Build only site pages:  inv mkdocs  Build API reference into site folder:  inv api  Build graphs into site folder:  inv graphs  Build examples into site folder:  inv examples  Build the whole site:  inv site", 
            "title": "Documentation"
        }, 
        {
            "location": "/dev-guide/#deploying", 
            "text": "Deploy to Clojars:  lein deploy clojars  Deploy site to gh-pages branch:  ghp-import -p site", 
            "title": "Deploying"
        }
    ]
}