<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">   
    <link rel="shortcut icon" href="../img/favicon.ico">

    <title>User Guide - Carry</title>

    <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/font-hack/2.018/css/hack.min.css">
    <link href='//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700,700italic&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../css/base.css" rel="stylesheet">
    <link href="../css/cinder.css" rel="stylesheet">
    <link rel="stylesheet" href="../css/highlight.css">


    <link href="../custom.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js"></script>
    <script>
    WebFont.load({
        google: {
            families: ['Open Sans', 'PT Sans']
        }
    });
    </script>

    
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">Carry</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Readme</a>
                    </li>
                
                
                
                    <li class="active">
                        <a href="./">User Guide</a>
                    </li>
                
                
                
                    <li >
                        <a href="../examples/">Examples</a>
                    </li>
                
                
                
                    <li >
                        <a href="../api/">API Reference</a>
                    </li>
                
                
                
                    <li >
                        <a href="../dev-guide/">Developer Guide</a>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="..">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../examples/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
                    <li>
                        <a href="https://github.com/metametadata/carry/">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="first-level active"><a href="#basics">Basics</a></li>
        
            <li class="second-level"><a href="#app">App</a></li>
            
        
            <li class="second-level"><a href="#model">Model</a></li>
            
        
            <li class="second-level"><a href="#signals">Signals</a></li>
            
        
            <li class="second-level"><a href="#creating-an-app">Creating an App</a></li>
            
        
            <li class="second-level"><a href="#control">Control</a></li>
            
        
            <li class="second-level"><a href="#actions">Actions</a></li>
            
        
            <li class="second-level"><a href="#reconcile">Reconcile</a></li>
            
        
            <li class="second-level"><a href="#usage-with-reagent">Usage with Reagent</a></li>
            
                <li class="third-level"><a href="#view-model">View Model</a></li>
            
                <li class="third-level"><a href="#view">View</a></li>
            
        
            <li class="second-level"><a href="#usage-with-figwheel">Usage with Figwheel</a></li>
            
        
    
        <li class="first-level "><a href="#advanced">Advanced</a></li>
        
            <li class="second-level"><a href="#middleware">Middleware</a></li>
            
        
            <li class="second-level"><a href="#debugger">Debugger</a></li>
            
        
            <li class="second-level"><a href="#writing-tests">Writing Tests</a></li>
            
        
            <li class="second-level"><a href="#elm-ish-architecture">Elm-ish Architecture</a></li>
            
        
            <li class="second-level"><a href="#usage-with-datascript">Usage with Datascript</a></li>
            
        
            <li class="second-level"><a href="#routing">Routing</a></li>
            
        
    
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h1 id="basics">Basics</h1>
<p>This section explains everything you need to start making apps with Carry. </p>
<h2 id="app">App</h2>
<p><img alt="spec" src="../graphs/app.svg" /></p>
<p>In a Carry application all the code you write is encapsulated behind a single <strong>app</strong> instance. 
An app is a map with keys:</p>
<ul>
<li><code>:model</code> - a read-only atom, an in-memory representation of an app state</li>
<li><code>:dispatch-signal</code> - a function for interaction with an app, always returns nil</li>
</ul>
<p>One can consider an app to be a black box which exposes its current state and modifies it on getting signals from an external world.
It can also affect an external world as a response to a signal, i.e. perform "side effects".</p>
<h2 id="model">Model</h2>
<p>Model represents an entire state of an app. </p>
<p>One can access app's model via <code>:model</code> key to obtain a read-only atom that can be dereferenced and watched, but cannot be mutated:</p>
<pre><code class="clj">(def my-model (:model app))

@my-model
;=&gt; {...}

(add-watch my-model :my-watcher
           (fn [_key _atom old-state new-state]
             (when (not= old-state new-state)
               (println &quot;model value has changed!&quot;))))

(reset! my-model {:foo :bar})
;=&gt; Error: read-only atom cannot be reset to {:foo :bar}

((:dispatch-signal app) some-model-changing-signal)
;=&gt; model value has changed!

(remove-watch my-model :my-watcher)
</code></pre>

<p>Carry requires a model value to be a map. This convention allows writing reusable packages that can store additional data into any Carry app.
As an example, <a href="https://github.com/metametadata/carry/tree/master/contrib/history">carry-history</a> adds <code>:token</code> to a model.</p>
<h2 id="signals">Signals</h2>
<p><strong>Signal</strong> is an object which represents a user's intention or, looking at it from a different angle, a system event. 
Signal can be synchronously sent to an app by calling its <code>dispatch-signal</code> function:</p>
<pre><code class="clj">((:dispatch-signal my-app) my-signal)
</code></pre>

<p>Carry accepts signals of any type. But usually signal is a just keyword with the "on-" prefix or
a serializable vector with a keyword and an additional payload:</p>
<pre><code class="clj">:on-clear-completed
[:on-update-todo id val]
[:carry-history.core/on-enter token]
</code></pre>

<h2 id="creating-an-app">Creating an App</h2>
<p>In order to create an instance of a Carry app a user has to pass a <strong>spec</strong> into <code>app</code> function:</p>
<pre><code class="clj">(let [my-app (carry/app my-spec)]
  ; ...
  )
</code></pre>

<p>A spec is a map with keys:</p>
<ul>
<li><code>:initial-model</code> - an initial model value</li>
<li><code>:control</code> - a function for handling signals</li>
<li><code>:reconcile</code> - a function for handling actions</li>
</ul>
<p>In other words, a spec is needed to define a runtime behavior of an app:</p>
<p><img alt="spec" src="../graphs/spec-and-app.svg" /></p>
<h2 id="control">Control</h2>
<p><strong>Controller (control function, control)</strong> is a part of an application responsible for handling incoming signals. 
It can dispatch new signals, modify app model (by dispatching actions) and perform any side effects (e.g. send data to a server).
Controller is free to contain asynchronous code. The signature of a control function:</p>
<pre><code class="clj">(defn control
  [model signal dispatch-signal dispatch-action])
</code></pre>

<ul>
<li><code>model</code> - a read-only atom, the same as app's <code>:model</code></li>
<li><code>signal</code> - an incoming signal </li>
<li><code>dispatch-signal</code> - a synchronous function for dispatching new signals, always returns <code>nil</code>, the same as app's <code>:dispatch-signal</code></li>
<li><code>dispatch-action</code> - a synchronous function for modifying a model, always returns <code>nil</code></li>
<li>Return value will not be used</li>
</ul>
<p>By convention, control should be able to at least handle <code>:on-start</code> and <code>:on-stop</code> signals.
As we'll see later, it's required by middleware with setup/teardown logic and to support hot reloading.</p>
<p>It is convenient (but not required) to use <a href="https://github.com/clojure/core.match">pattern matching</a> 
to switch between signals and destructure signals with payload.
As an example, this is a controller from <a href="../examples/#friend-list">friend-list</a> demo app:</p>
<pre><code class="clj">(ns friend-list.core
  (:require [carry-history.core :as h]
            ; ...
            [goog.functions :refer [debounce]]
            [cljs.core.match :refer-macros [match]]))

; It's recommended to create a factory function if controller uses external dependencies.
; It makes code more decoupled and 
; easier to unit test (stubs/mocks can be easily used instead of real implementations).
; In this example browser history manager and API client are external dependencies.
(defn -new-control
  [history api-search]
  ; Some helper functions.
  ; On successful search a new :on-search-success signal will be dispatched.
  (let [search (fn [q dispatch-signal] (api-search q #(dispatch-signal [:on-search-success q %])))
        search-on-input (debounce (fn [q dispatch-signal]
                                    (h/push-token history q)
                                    (search q dispatch-signal))
                                  300)]
    ; Function name is specified for better stacktraces.
    (fn control
      [model signal dispatch-signal dispatch-action]
      (match signal
             ; This application has no custom setup/teardown logic
             ; so just return nil on standard signals:             
             :on-start nil
             :on-stop nil

             ; Macro will throw an exception on unknown signals.

             ; Signal destructuring example 
             [:on-input q]
             (do
               ; Update model.
               (dispatch-action [:set-query q])

               ; Begin (possibly async) searching.
               (search-on-input q dispatch-signal))

             ; ...

             [:on-search-success q friends]
             ; Note that model has to be dereferenced to get its value.
             (if (= (:query @model) q)
               (dispatch-action [:set-friends friends])
               (println &quot;ignore response for&quot; (pr-str q)
                        &quot;because current query is&quot; (pr-str (:query @model))))))))

; ...

; Dependencies will be injected in a spec factory function:
(defn new-spec
  [history api-search]
  {; ...
   :control (-new-control history api-search)})

; ...

; Create and start an app using concrete dependencies.
(def my-app (carry/app (new-spec my-history my-api-client)))
((:dispatch-signal app) :on-start)
</code></pre>

<h2 id="actions">Actions</h2>
<p><strong>Action</strong> is an object which represents an intention to modify a model.
Actions can be dispatched only from within a control function via <code>dispatch-action</code>.</p>
<p>Similar to signals, actions are usually keywords or vectors, for instance:</p>
<pre><code class="clj">:increment
[:set-query q]
</code></pre>

<h2 id="reconcile">Reconcile</h2>
<p><strong>Reconciler (reconcile function, reconcile)</strong> is a part of an application responsible for handling incoming actions.
It's a pure function which returns a new model value based on a current model value and an incoming action.
On getting an action an app passes it into a reconciler and then resets app model value with the result.</p>
<p>A simple example from <a href="../examples/#friend-list">friend-list</a> demo app:</p>
<pre><code class="clj">(defn -reconcile
  [model action]
  (match action
         [:set-query q]
         (assoc model :query q)

         [:set-friends friends]
         (assoc model :friends friends)))
</code></pre>

<p>It's important to not put any async code, side effects or nondeterministic code (e.g. random number generation)
into reconciler. Otherwise, it will make replaying actions unpredictable and break time traveling debugging.</p>
<h2 id="usage-with-reagent">Usage with Reagent</h2>
<p>Carry can work with any view layer that is able to re-render UI in response to app model changes.
This chapter is about tying Carry with <a href="https://github.com/reagent-project/reagent">Reagent</a> 
(a ClojureScript wrapper for <a href="https://facebook.github.io/react/">React</a>)
using <a href="https://github.com/metametadata/carry/tree/master/contrib/reagent/">carry-reagent</a> package: </p>
<pre><code class="clj">(ns app.core
  (:require [carry.core :as carry]
            [carry-reagent.core :as carry-reagent]
            [reagent.core :as r]))

; ...

; Define app view model and view:

(defn my-view-model
  [model]
  ; define a view model...
)

(defn my-view
  [view-model dispatch]
  ; a Reagent component that uses data from a view-model and dispatches signals on events...
)

(let [; Create an app.
      app (carry/app my-spec)

      ; &quot;Connect&quot; app, view model and view to create a Reagent component.
      [_ app-view] (carry-reagent/connect app my-view-model my-view)]
    ; Render component into DOM.
    (r/render app-view (.getElementById js/document &quot;root&quot;))

    ; ...
)
</code></pre>

<p>App view is constructed using <code>carry-reagent.core/connect</code> function:</p>
<pre><code class="clj">(connect [app view-model view])
</code></pre>

<ul>
<li><code>app</code> - Carry app instance</li>
<li><code>view-model</code> - a function which produces a view model</li>
<li><code>view</code> - a Reagent component</li>
<li>Returns a pair <code>[view-model-instance view-component]</code> (view model is returned mainly for debugging)</li>
</ul>
<p><code>view-model</code> function is called once on <code>connect</code> call.
Then returned view model instance is passed as an argument into <code>view</code> function to produce a final view component.
A view thereby listens to a view model that in turn listens to a model:</p>
<p><img alt="pattern" src="http://metametadata.github.io/carry/graphs/pattern.svg" /></p>
<p>In the next section we'll see how to define a view model.</p>
<h3 id="view-model">View Model</h3>
<p><strong>View model</strong> contains all the data needed to render a UI.
It can compute derived model data, split lists of objects into pages, calculate which buttons are enabled, 
determine which app page to show depending on current URL, etc.</p>
<p>Usually view model is a map of Reagent reactions. An example from <a href="../examples/#todomvc">TodoMVC</a> app:</p>
<pre><code class="clj">(ns app.view-model
  (:require ; ...
            [carry-reagent.core :as carry-reagent])
  (:require-macros [reagent.ratom :refer [reaction]]))

(defn view-model
  [model]
  (let [; ...
        ; Wrap todo items in a reaction.
        all-todos (reaction (:todos @model))]
    (-&gt; model
        ; This helper function call will return {:field (reaction (:field @model))} map.
        ; Note: :field contains the value of a new todo input.
        (carry-reagent/track-keys [:field])

        ; Additional view model fields are reactions 
        ; which will be recalculated if (and only if) all-todos value changes:
        (assoc :has-todos? (reaction (-&gt; @all-todos count pos?))
               :all-completed? (reaction (every? :completed? @all-todos))
               ; ...
               ))))
</code></pre>

<p>Argument <code>model</code> is a read-only <strong>Reagent atom (ratom)</strong> that behaves almost exactly as a read-only model atom (i.e. <code>(:model app)</code>), 
but can also be used in Reagent components and reactions.</p>
<p><strong>Reaction</strong> is a special ratom-like object that is created using Reagent's <code>reaction</code> macro.
It is lazily computed from other ratoms/reactions.
Any Reagent component that dereferences a reaction is going to be re-rendered when reaction value updates.</p>
<h3 id="view">View</h3>
<p>An example from <a href="../examples/#todomvc">TodoMVC</a> app:</p>
<pre><code class="clj">; A plain Reagent component which is redrawn when input arguments change.
(defn -header
  [field dispatch]
  ; Reagent uses Hiccup-like syntax for defining HTML.
  [:header.header
   [:h1 &quot;todos&quot;]

   ; Input value is equal to field arg value.
   [:input.new-todo {:placeholder &quot;What needs to be done?&quot;
                     :value       field

                     ; Dispatch signals on input events.
                     :on-change   #(dispatch [:on-update-field (.. % -target -value)])
                     :on-key-down #(when (-enter-key? %) (dispatch :on-add))}]])

; Top app component that is passed into connect function.
(defn view
  ; Destructure view model map for cleaner code in the function body.
  [{:keys [field has-todos? all-completed?
           ; ...
           ] :as _view-model}
   dispatch]
  [:section.todoapp
   ; Deref |field| reaction to get its value for rendering.
   ; Derefing also makes parent component start watching for |field| changes 
   ; so that -header will be re-rendered on |field| updates. 
   [-header @field dispatch]

   ; ...
   ]))
</code></pre>

<p>As you can see, we get reactions from a view model and deref them to render actual values.
Reagent will then "magically" re-render components when the reactions passed into them are updated.</p>
<h2 id="usage-with-figwheel">Usage with Figwheel</h2>
<p>With <a href="https://github.com/bhauman/lein-figwheel">Figwheel</a> Leiningen plugin it is possible to:</p>
<ul>
<li>compile and reload app code in browser on source code changes</li>
<li>communicate with a running app via REPL</li>
</ul>
<p>All the Carry <a href="../examples">examples</a> use Figwheel for development builds and 
rely on the "bare" <a href="https://github.com/emezeske/lein-cljsbuild">lein-cljsbuild</a> for production builds.</p>
<p>The main thing to remember is to stop the currently running app before hot reload 
in order to unsubscribe it from browser events and free memory.
Here's how you can structure your main app file to be used with Figwheel: </p>
<pre><code class="clj">(ns app.core
  (:require [carry.core :as carry]
            [carry-reagent.core :as carry-reagent]
            [reagent.core :as r]))

; ...

(defn main
  []
  (let [app (carry/app my-spec)
        [app-view-model app-view] (carry-reagent/connect app my-view-model my-view)]
    (r/render app-view (.getElementById js/document &quot;root&quot;))

    ; Start the app.
    ((:dispatch-signal app) :on-start)

    ; For debugging purposes add view-model into returned map.
    (assoc app :view-model app-view-model)))

; Start new app and save it into the global var for debugging in REPL.
(def app (main))

;;;;;;;;;;;;;;;;;;;;;;;; Figwheel stuff
; These functions should be specified in project.clj :figwheel map.

; Stop current app before loading a new one.
(defn before-jsload
  []
  ((:dispatch-signal app) :on-stop))

(defn on-jsload
  []
  #_(. js/console clear))
</code></pre>

<h1 id="advanced">Advanced</h1>
<h2 id="middleware">Middleware</h2>
<p><strong>Middleware</strong> is a function that gets an app spec and returns an updated spec
in order to introduce some new app behavior (such as logging, syncing with server, crash reporting).</p>
<p>Multiple middleware can be applied in a chain to produce a new spec.
For instance, <a href="../examples/#todomvc">TodoMVC</a> app spec is wrapped by three middleware:</p>
<pre><code class="clj">(defn new-spec
  [history storage storage-key todo-titles]
  (-&gt; {:initial-model (model/new-model todo-titles)
       :control       control
       :reconcile     reconcile}

      ; 1
      (schema/add model/Schema)

      ; 2
      (persistence/add storage storage-key {:blacklist #{::h/token}})

      ; 3
      (h/add history)))
</code></pre>

<p>As an example, this is a simple middleware which logs all actions and signals coming through an app:</p>
<pre><code class="clj">(ns carry-logging.core)

(defn add
  &quot;Will print all signals and actions to console.&quot;
  ([spec] (add spec &quot;&quot;))
  ([spec prefix]
   (-&gt; spec
       ; Wrap control to log signals.
       (update :control (fn wrap-control [control]
                          (fn logged-control [model signal dispatch-signal dispatch-action]
                            (try
                              ; Log.
                              (.group js/console (str prefix &quot;signal &quot; (pr-str signal)))

                              ; Call original function.
                              (control model signal dispatch-signal dispatch-action)

                              ; Always close the group.
                              (finally
                                (.groupEnd js/console))))))

       ; Wrap reconcile to log actions.
       (update :reconcile
               (fn wrap-reconcile [reconcile]
                 (fn logged-reconcile [model action]
                   ; Log.
                   (.log js/console (str prefix &quot;action&quot;) (pr-str action))

                   ; Call original function.
                   (reconcile model action)))))))
</code></pre>

<p>More complex middleware can:</p>
<ul>
<li>Modify initial model.</li>
<li>Intercept <code>:on-start</code>/<code>:on-stop</code> signals.</li>
<li>Dispatch new signals and actions to an app.
By convention, they must use namespaced keywords (e.g. <code>:my-middlware.core/on-something</code>) to prevent a name clash with other signals.</li>
<li>Dispatch own signals and actions which should not be handled by an app. They must also use namespaced keywords.</li>
<li>Subscribe to model changes.</li>
<li>Have injected dependencies.</li>
</ul>
<p>All these cases are demonstrated by <a href="https://github.com/metametadata/carry/tree/master/contrib/history">carry-history</a> middleware:</p>
<pre><code class="clj">(ns carry-history.core
  ; ...
)

(defn -wrap-initial-model
  [app-initial-model]
  (merge {::token &quot;/&quot;} app-initial-model))

; History will be injected on applying the middleware.
(defn -wrap-control
  [app-control history]
  (let [unlisten (atom nil)]
    (fn control
      [model signal dispatch-signal dispatch-action]
      (match signal
             ; Intercept :on-start signal.
             :on-start
             (do
               ; Let the wrapped app start first.
               (app-control model signal dispatch-signal dispatch-action)

               ; Start listening to model updates.
               (add-watch model ::token-watcher
                          (fn [_key _atom old-state new-state]
                            ; ...
                            ))

               ; Start listening to history events.
               (reset! unlisten
                       (listen history #(dispatch-signal [::on-history-event ; ...
                                                          ])))

               ; ...               
               )

      ; Intercept clean up signal.
      :on-stop
      (do
        ; Unsubscribe from history events. 
        ; Otherwise, on hot reload unused listeners will stay in memory.
        (@unlisten)

        ; There's no need to remove model watchers on hot reload 
        ; because they will be garbage-collected with the model.

        ; Let the wrapped app continue cleaning up.
        (app-control model signal dispatch-signal dispatch-action))

      ; Middleware-specific signal that will not be passed further to an app.
      [::on-history-event {:token token :browser-event? browser-event? :event-data event-data}]
      (do
        ; Dispatch a middleware-specific action.
        (dispatch-action [::set-token token])

        (when (or browser-event? (:treat-as-browser-event? event-data))
          ; Dispatch a signal to an app.
          (dispatch-signal [::on-enter token])))

      ; Pass other signals further.
      :else
      (app-control model signal dispatch-signal dispatch-action)))))

(defn -wrap-reconcile
  [app-reconcile]
  (fn reconcile
    [model action]
    (match action
           ; A middleware-specific action.
           [::set-token token]
           (assoc model ::token token)

           ; Pass other actions further.
           :else
           (app-reconcile model action))))

; History is an injected dependency.
(defn add
  [spec history]
  (-&gt; spec
      (update :initial-model -wrap-initial-model)
      (update :control -wrap-control history)
      (update :reconcile -wrap-reconcile)))
</code></pre>

<p>Also see: <a href="../index.html#middleware">ready-to-use middleware packages</a>.</p>
<h2 id="debugger">Debugger</h2>
<p>One of the main features of Carry pattern is that it allows time traveling debugging
similar to <a href="http://debug.elm-lang.org/">Elm's Debugger</a>,
<a href="https://github.com/gaearon/redux-devtools">Redux DevTools</a> and <a href="http://www.cerebraljs.com/debugger">Cerebral Debugger</a>.</p>
<p>Carry has its own visual time traveling debugger with next features:</p>
<ul>
<li>Debugger records all app signals and actions and shows them as a tree.</li>
<li>A signal is displayed as a respective tree leaf if it's dispatched from inside another signal.</li>
<li>Debugger records results of every action so that every past model value can be logged to console.</li>
<li>Any action can be disabled/enabled. On toggling an action debugger will reset app model 
to its initial value and <strong>replay</strong> all enabled actions.
This way user can immediately see how the app would look like if the action never took place.
Action replaying is possible because actions are always pure and change app model in a predictable way.
On the other hand, it's impossible to predictably replay signals as they can perform async side effects.</li>
<li>Clicking a signal toggles all its child actions.</li>
<li>Clicking "Replay" button enables debugger's "replay mode" and marks already recorded actions as "to be replayed".
These actions are saved into local storage and will be automatically replayed on next app start.
In combination with Figwheel hot reloading this allows editing reconciler code
and immediately see how it affects a final app state (effectively "changing the past").</li>
<li>Debugging session can be saved into a file and then loaded.</li>
<li>"Clear" button removes all recorded signals and actions without modifying current app state.</li>
<li>"Vacuum" removes all disabled actions and "dangling" signals without enabled actions.</li>
<li>"Reset" resets an app to its initial state and clears recorded signals and actions.</li>
<li>Currently debugger uses Reagent+jQuery UI to render a resizable overlay view.</li>
</ul>
<p><a href="http://i.imgur.com/ZOH6Noj.png">
  <img src="http://i.imgur.com/ZOH6Noj.png" alt="debugger" style="width: 50vw; display: block; margin: 0 auto;"/>
</a></p>
<p>To use a debugger developer has to apply <a href="https://github.com/metametadata/carry/tree/master/contrib/debugger">carry-debugger</a> middleware,
connect a debugger view and render it alongside an app view:</p>
<pre><code class="clj">(ns app.core
  (:require [carry.core :as carry]
            [carry-reagent.core :as carry-reagent]
            [carry-debugger.core :as debugger]
            [reagent.core :as r]
            [hodgepodge.core :as hp]
            ; ...
            ))

; ...

(defn main
  []
  (let [; Use hodgepodge lib for dealing with browser's local storage.
        storage hp/local-storage

        ; Apply middleware.
        app-spec (-&gt; my-spec
                     ; Middleware requires a storage and a unique storage key.
                     (debugger/add storage :my-debugger-model))

        ; App and UI.
        app (carry/app app-spec)
        [_ app-view] (carry-reagent/connect app my-view-model my-view)

        ; Connect debugger UI.
        [_ debugger-view] (debugger/connect app)]
    ; Render app and debugger views.
    (r/render [:div app-view debugger-view] (.getElementById js/document &quot;root&quot;))

    ; Start.
    ((:dispatch-signal app) :on-start)

    ; ...
    ))
</code></pre>

<p>There are cases when you'd like to check if debugger is in replay mode.
For instance, <a href="https://github.com/metametadata/carry/tree/master/contrib/history">carry-history</a>
middleware doesn't send its initial <code>:on-enter</code> signal in replay mode.
Such behavior makes development in replay mode more pleasant as developer expects only marked actions to be replayed on app start.
Replay mode can be determined by looking at <code>[:carry-debugger.core/debugger :replay-mode?]</code> path in a model map:</p>
<pre><code class="clj">(ns carry-history.core
  ; ...
  )

; ...

(defn -wrap-control
  [app-control history]
  (let [unlisten (atom nil)]
    (fn control
      [model signal dispatch-signal dispatch-action]
      (match signal
             :on-start
             (do
               (app-control model signal dispatch-signal dispatch-action)

               ; ...

               ; Check if we're in replay mode before sending an initial signal
               (when (not (-&gt; @model :carry-debugger.core/debugger :replay-mode?))
                 (dispatch-signal [; ... 
                                   ])))
             ; ...
             ))))
; ...
</code></pre>

<h2 id="writing-tests">Writing Tests</h2>
<p>It is comparatively easy to unit test a Carry app because its behavior 
is implemented in two functions with explicit dependencies: <code>control</code>, <code>reconcile</code>.
<a href="https://github.com/metametadata/carry/tree/master/contrib/reagent/">Reagent bindings</a>
may also add two more simple functions: <code>view-model</code>, <code>view</code>.</p>
<p>Let's look at how these functions are tested in
<a href="https://github.com/metametadata/carry/tree/master/examples/friend-list/">friend-list</a> example:</p>
<p><strong><code>1. (control [model signal dispatch-signal dispatch-action])</code></strong> </p>
<p>Control function handles incoming signals to perform side effects, dispatch new signals and actions.
Such behavior is easy to test using <a href="https://en.wikipedia.org/wiki/Mock_object">mock</a> functions.
This test uses <a href="https://github.com/metametadata/clj-fakes">clj-fakes</a> 
isolation framework for recording and checking <code>dispatch-signal</code> and <code>dispatch-action</code> calls
on receiving <code>:on-enter</code> signal:</p>
<pre><code class="clj">(ns unit.controller
  (:require
    [friend-list.core :as friend-list]
    [carry.core :as carry]
    [carry-history.core :as h]
    [cljs.test :refer-macros [deftest is testing]]
    [clj-fakes.core :as f :include-macros true]
    ;...
    ))

(deftest
  on-navigation-updates-query-and-searches
  (f/with-fakes
    (let [search (f/fake [[:_new-token f/any?] #(%2 :_found-friends)])
          {:keys [control]} (friend-list/new-spec :_history search)
          dispatch-signal (f/recorded-fake)
          dispatch-action (f/recorded-fake)]
      ; act
      (control :_model [::h/on-enter :_new-token] dispatch-signal dispatch-action)

      ; assert
      (is (f/was-called-once dispatch-action [[:set-query :_new-token]]))
      (is (f/was-called-once dispatch-signal [[:on-search-success :_new-token :_found-friends]])))))
</code></pre>

<p>There are several interesting things demonstrated:</p>
<ul>
<li>Test is written using <a href="http://c2.com/cgi/wiki?ArrangeActAssert">Arrange-Act-Assert (AAA)</a> pattern.
Comments are added to better separate these logical blocks. </li>
<li>Control function is taken from the spec created using public <code>friend-list/new-spec</code> function.
It could be tempting to instead test by using <code>friend-list/-new-control</code> helper function directly.
But accessing private members is a bad practice
and there can also be middleware applied inside <code>new-spec</code> which can affect the tested behavior.</li>
<li>Instead of using a real async API client we create a fake <code>search</code> 
function which synchronously returns the expected result and 
will throw an exception on calls with unexpected arguments.</li>
<li>Dynamic nature of ClojureScript allows us to use keywords (<code>:_history</code>, <code>:_found-friends</code>, <code>:_model</code>, <code>:_new_token</code>) instead
of creating objects of correct type
when we know that their type doesn't really matter in the test case.
It makes tests more focused and readable.</li>
</ul>
<p><strong><code>2. (reconcile [model action])</code></strong></p>
<p>Reconciler is the easiest function to test because it's pure:</p>
<pre><code class="clj">(deftest
  sets-query
  (let [{:keys [initial-model reconcile]} (friend-list/new-spec :_history :_search)]
    (is (= &quot;new query&quot;
           (:query (reconcile initial-model [:set-query &quot;new query&quot;]))))))
</code></pre>

<p>Here again we first create a spec in order to get <code>initial-model</code> value and <code>reconcile</code> function.</p>
<p>Notice, that it's impossible to use a <code>:_new_query</code> keyword because app uses 
<a href="https://github.com/metametadata/carry/tree/master/contrib/schema">carry-schema</a>
middleware forcing us to use a string value <code>"new-query"</code> on reconciling.</p>
<p><strong><code>3. (view-model [model])</code></strong></p>
<p>These tests make sure that view model really contains Reagent reactions
at <code>:query</code> and <code>:friends</code> keys:</p>
<pre><code class="clj">(ns unit.view-model
  (:require
    [friend-list.core :as friend-list]
    [reagent.core :as r]
    [schema-generators.generators :as g]
    [cljs.test :refer-macros [deftest is]])
  (:require-macros [reagent.ratom :refer [run!]]))

(defn test-view-model-tracks-model-key
  [model-key act-action expected-view-model-value]
  (let [{:keys [initial-model reconcile]} (friend-list/new-spec :_history :_search)
        model (r/atom initial-model)
        view-model (friend-list/view-model model)
        witness (atom nil)]
    (is (contains? view-model model-key) &quot;self-test&quot;)
    (run! (reset! witness @(model-key view-model)))

    ; act
    (swap! model reconcile act-action)

    ; force reaction updates
    (r/flush)

    ; assert
    (is (= expected-view-model-value @witness))))

(deftest
  tracks-query
  (test-view-model-tracks-model-key :query [:set-query &quot;new query&quot;] &quot;new query&quot;))

(deftest
  tracks-friends
  (let [new-friends (g/sample 3 friend-list/Friend)]
    (test-view-model-tracks-model-key :friends [:set-friends new-friends] new-friends)))
</code></pre>

<ul>
<li><code>test-view-model-tracks-model-key</code> is a helper function.</li>
<li><code>r/flush</code> is needed because Reagent doesn't immediately propagate reaction updates (starting from v0.6.0).</li>
<li><a href="https://github.com/plumatic/schema-generators">schema-generators</a> library is used to automatically generate
<code>new-friends</code> fixture instead ofunction to testf coding it by hand.</li>
</ul>
<p><strong><code>4. (view [view-model dispatch])</code></strong> (This section is a WIP.)</p>
<p>Unit testing this function is probably not critical because most error-prone UI
code is located in <code>view-model</code>.</p>
<h2 id="elm-ish-architecture">Elm-ish Architecture</h2>
<p>This section is a WIP. Please see examples in a meantime.</p>
<h2 id="usage-with-datascript">Usage with Datascript</h2>
<p>This section is a WIP. Please see examples in a meantime.</p>
<h2 id="routing">Routing</h2>
<p>This section is a WIP. Please see examples in a meantime.</p></div>
        
    </div>

    <footer class="col-md-12 text-center">
        <hr>
        <p>
        <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p></small>
    </footer>

    <script src="../js/jquery-1.10.2.min.js"></script>
    <script src="../js/bootstrap-3.0.3.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>
    var base_url = '..';
    </script>
    <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
    <script src="../js/base.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal">
                        <span aria-hidden="true">&times;</span>
                        <span class="sr-only">Close</span>
                    </button>
                    <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                </div>
                <div class="modal-body">
                    <p>
                        From here you can search these documents. Enter your search terms below.
                    </p>
                    <form role="form">
                        <div class="form-group">
                            <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                        </div>
                    </form>
                    <div id="mkdocs-search-results"></div>
                </div>
                <div class="modal-footer">
                </div>
            </div>
        </div>
    </div>

    </body>

</html>
